# Transport Layer

**전송 계층(transport layer)**는 송수신 호스트에서 실행되는 프로세스 간의 종단 연결을 지원한다. 송신 호스트의 전송 계층은 상위 계층에서 내려온 데이터를 분할(segementation)하여 전송하며 수신 호스트의 전송 계층은 하위 계층에서 올라온 데이터를 병합(reassembly)한다.



## 전송 계층의 프로토콜

전송 계층에서 사용하는 프로토콜에는 IP 위에서 동작하는 TCP와 UDP가 있다. 이때 TCP는 연결형 서비스를 지원하며 UDP는 비연결형 서비스를 지원한다. 전송 계층 프로토콜은 커널 내부에 구현되어, 상위 계층은 시스템 콜을 호출하여 프로토콜이 제공하는 서비스를 사용할 수 있다.



## TCP

**TCP(Transmission Control Protocol)**는 연결형 서비스로서 오류 제어, 흐름 제어, 혼잡 제어를 통하여 신뢰성 있는 데이터 전송을 보장한다. TCP에서 사용하는 데이터의 단위를 **세그먼트(segment)**라고 한다. 세그먼트는 TCP 헤더와 데이터 필드로 나뉜다.

### TCP Header

![tcp segment](https://user-images.githubusercontent.com/57662010/195682499-2f7fffd4-b7ea-479b-8bb1-9b70d3a214de.png)

TCP 헤더에서 각각의 필드는 다음을 나타낸다.

- **송신 포트(source port), 수신 포트(destination port)**: 프로세스에게 할당되는 네트워크 자원을 포트(port)라고 하며, 포트를 구분하는 주소를 포트 번호라고 한다. 송신 포트와 수신 포트는 각각 송신 프로세스와 수신 프로세스에게 할당된 네트워크 포트를 구분하는 주소이다. TCP와 UDP는 별도의 주소 공간을 가지므로 같은 포트 번호를 독립적으로 사용할 수 있다.
- **순서 번호(Sequence Number)**: 송신 프로세스가 지정한 순서 번호로, 전송되는 바이트의 수를 기준으로 증가한다.
- **응답 번호(Acknowledgement Number)**: <u>다음에 수신하기를 기대하는 데이터의 순서 번호</u>를 표시한다. 즉, `응답 번호 - 1`까지의 모든 데이터를 제대로 수신하였음을 송신자에게 응답한다. `ACK` 플래그가 1이면 유효하다. 연결 설정이나 연결 해제를 할 때에는 수신한 데이터가 없지만 순서 번호가 1씩 증가한다.
- **데이터 오프셋(Data Offset)**: TCP 헤더의 크기를 나타낸다. 32비트 워드 단위이다.
- **예약(Reserved)**
- **윈도우 크기(Window size)**: 슬라이딩 윈도우 프로토콜에서 수신 윈도우의 버퍼 크기를 지정하기 위해 사용한다. 수신 프로세스가 수신할 수 있는 바이트의 수를 나타낸다.
- **체크섬(Checksum)**: TCP 세그먼트가 변형되었는지 오류를 검출하는데 사용한다. IP 프로토콜에서 사용하는 오류 검출 알고리즘을 사용한다.
- **긴급 포인터(Urgent Pointer)**: 수신 프로세스의 응용 계층에 긴급 데이터가 도착했음을 알리기 위해 사용한다. `URG` 플래그가 1이면 유효하다.
- 플래그들
  - `ECE`, `CWR`: 혼잡 제어에 사용한다.
  - `URG`: 긴급 포인터 필드가 유효한지 나타낸다.
  - `ACK`: 응답 번호 필드가 유효한지 나타낸다. 연결 설정 과정에서 전송되는 첫번째 세그먼트를 제외한 모든 세그먼트의 `ACK` 비트는 1이다.
  - `PSH`: 현재 세그먼트의 데이터를 상위 계층에 즉시 전달하도록 지시할 때 사용한다.
  - `RST`: 세그먼트를 재전송해야한다는 것을 나타낸다. 연결을 재설정하거나, 유효하지 않은 세그먼트에 대해 응답할 때 사용한다. 
  - `SYN`: 연결 설정을 요구하는 플래그로 연결을 설정할 때 사용한다.
  - `FIN`: 연결 해제를 요구하는 플래그로 연결을 해제할 때 사용한다.
- 옵션(Options)/패딩(Padding): 최대 40바이트로 다양한 종류의 부가 정보를 전달하는데 사용한다. 패딩 필드는 헤더의 크기를 4바이트 단위로 맞추기 위해 사용한다.



## TCP 프로토콜에서 데이터의 전송

TCP 프로토콜은 전이중 방식의 양방향 통신을 지원한다. 따라서 전송 데이터와 응답 데이터를 함께 전송하는 피기배킹(Piggybaking) 기능을 사용한다.



### TCP 연결 설정(3-way handshaking)

![image](https://user-images.githubusercontent.com/57662010/195692118-fc854fa0-6317-4eb9-bf1f-aab67510988d.png)

프로세스 A가 프로세스 B에게 연결 설정을 요구한다고 하자.

1. 프로세스 A는 `SYN` 플래그를 지정하여 프로세스 B에게 연결 설정을 요구한다. 임의의 순서 번호 `seq=10`을 보냈다.
2. 프로세스 B는 `SYN` 플래그와 `ACK` 플래그를 지정하여 프로세스 A와의 연결 설정에 긍정한다. 임의의 순서 번호 `seq=50`와 응답 번호 `ack=11`을 보낸다.
3. 프로세스 A는 `ACK` 플래그를 지정하여 연결 긍정하는 세그먼트를 수신받았음을 알린다. `seq=11`, `ack=51`을 보낸다.



### TCP 연결 해제(4-way handshaking)

프로세스 A가 프로세스 B에게 연결 해제를 요구한다고 하자.

1. 프로세스 A는 `FIN` 플래그를 지정하여 프로세스 B에게 연결 해제를 요구한다. 이때 순서 번호가 `seq=16`, 응답 번호가 `ack=61`이라고 하자.
2. 프로세스 B는 `ACK` 플래그를 지정하여 프로세스 A의 연결 해제를 요구하는 세그먼트를 성공적으로 수신받았음을 알린다. 순서 번호는 `seq=61`, 응답 번호는 `ack=17`이다.
3. 프로세스 B는 `FIN` 플래그를 지정하여 연결 해제에 긍정한다. 순서 번호는 `seq=61`, 응답 번호는 `ack=17`이다. 프로세스 B가 이 세그먼트를 보내기 전까지 프로세스 A와 B는 통신할 수 있다.
4. 프로세스 A가 `ACK` 플래그를 지정하여 프로세스 B의 연결 해제를 긍정하는 세그먼트를 성공적으로 수신받았음을 알린다. 프로세스 A와 B는 최종적으로 연결이 해제된다.



### TCP Checksum

![의사 IP 헤더](https://media.geeksforgeeks.org/wp-content/uploads/20200329123054/TCP21.png)

TCP 헤더와 본문, IP 헤더의 일부로 만든 의사 IP 헤더를 대상으로 한다. IP 헤더는 네트워크 계층과 전송 계층에서 검사되어 IP 헤더의 모든 오류를 감지할 수 있게 된다.

1. 송신 프로세스가 데이터를 16비트 단위로 나누고 그 합을 구한다.  (carry는 wrap around한다.) 합에 대하여 1의 보수를 취한 값을 TCP 헤더의 Checksum 필드에 넣는다.
2. 수신 프로세스도 체크섬을 구한 후 Checksum 필드의 값과 더한다. 모든 자릿수가 1이면 정상이다.

1의 보수 구하는 방법 [출처](https://coding-factory.tistory.com/653)

### 오류 제어

데이터 전송 오류가 발생하면 수신 프로세스는 응답을 하지 않는다. 송신 프로세스는 타임아웃 기능을 사용하여 응답이 오지 않으면 재전송을 실행한다.



### 흐름 제어

수신 프로세스의 데이터 수신 속도가 송신 프로세스의 데이터 송신 속도보다 느린 경우 데이터 분실이 일어날 수 있다. 데이터 분실이 일어나면 수신 프로세스는 응답을 하지 않고, 송신 프로세스가 타임아웃 기능을 수행하면 네트워크 전송 효율이 떨어진다.

TCP는 슬라이딩 윈도우 프로토콜을 사용하여 흐름 제어를 지원한다. 수신 프로세스는 헤더의 Window size 필드에 적절한 값을 지정한다. 송신 프로세스는 해당 값까지는 연속으로 데이터를 전송하고 그 이상의 데이터는 수신 프로세스로부터 응답이 도착하면 전송한다.



### 혼잡 제어

ECN(Explicit Congestion Notification) 기능은 라우터가 송신 프로세스에 명시적으로 혼잡의 발생을 알려 송신 프로세스가 스스로 트래픽을 완화하도록 하는 기술이다. TCP 헤더의 `ECE`, `CWR` 플래그와 IP 헤더의 `ECN` 필드로 ECN을 지원한다.

라우터는 IP 헤더 `ECN` 플래그에 `CE` 값을 지정하여 수신 프로세스에게 혼잡의 발생을 알린다. 수신 프로세스는 `ECE` 플래그를 지정하여 송신 프로세스에게 혼잡의 발생을 중개한다. `ECE`  플래그를 수신한 송신 프로세스는 `CWR` 플래그를 지정하여 전송 윈도우의 크기를 줄였음을 통지한다. 라우터가 TCP 프로토콜을 지원하지 않으므로 수신 프로세스가 혼잡의 발생을 중개한다.



## UDP

**UDP(User Datagram Protocol)**는 비연결형 서비스를 제공하므로, 연결형 서비스를 제공하는 TCP보다 신뢰성이 떨어진다. UDP에서 사용하는 데이터의 단위를 **데이터그램(datagram)**라고 한다. 데이터그램은 UDP 헤더와 데이터 필드로 나뉜다.

### UDP Header

![udp datagram](https://user-images.githubusercontent.com/57662010/195682494-7fec1634-f11e-4f0a-8f24-f590fafb491e.png)

UDP 헤더에서 각각의 필드는 다음을 나타낸다.

- **송신 포트(source port), 수신 포트(destination port)**: 송신 프로세스와 수신 프로세스를 구분하는 포트 번호이다.
- **길이(Length)**: UDP 데이터그램의 크기를 나타낸다. 바이트 단위이며 헤더의 길이는 8바이트이다.
- **체크섬(Checksum)**: 프로토콜 헤더와 데이터에 대한 체크섬 값이다. 수신 프로세스는 체크섬 오류를 발견하면 데이터그램을 버린다.

### 데이터그램의 전송

UDP는 Best effort 전달 방식을 지원한다. 이는 목적지까지 도착할 수 있도록 최선을 다하나 목적지에 도착하는 것은 보장하지 않는 방식을 의미한다. 또한 흐름 제어 기능 등을 제공하지 않아 데이터그램 분실이나 도착 순서가 변경되는 오류가 발생할 수 있다. 이러한 오류를 해결하려면 응용 계층의 프로세스가 내부적으로 기능을 구현해야한다.

### TCP와의 비교

연결형 서비스를 제공하기 위한 정보를 요구하지 않아 헤더의 구조가 TCP보다 간단하여, 데이터의 처리가 빠르다. 따라서 패킷 손실에는 둔감하고 데이터 전송 시간이나 실시간성에 예민한 멀티미디어 응용 환경(스트리밍)에 사용된다.



## 참고

- [The OSI Model](https://www.coengoedegebure.com/osi-model/)
- 쉽게 배우는 데이터 통신과 컴퓨터 네트워크
- [geeksforgeeks - Why TCP Connect Termination Need 4-Way-Handshake?](https://www.geeksforgeeks.org/why-tcp-connect-termination-need-4-way-handshake/)
- https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start



(TODO) 슬라이딩 윈도우 프로토콜

## 스터디

### TCP가 무엇인가

전송 계층의 프로토콜로 네트워크에서 데이터를 신뢰성 있게 전송한다.

- TCP는 어떻게 신뢰성을 보장하는가?

  3-way handshake 과정으로 연결을 설정하며, 4-way handshake 과정으로 연결을 해제한다. 패킷 순서를 보장하기 위해 seq number와 ack number를 사용한다. 오류 제어, 흐름 제어, 혼잡 제어 기능을 제공한다.

### 3-way handshake가 무엇인가요

TCP 프로토콜에서 클라이언트와 서버가 데이터를 주고받기 전 연결을 설정하는 과정이다. 최초에 클라이언트가 서버에게 연결을 요청하는 SYN 패킷을 보낸다. 서버는 클라이언트에게 연결을 허가하는 ACK, SYN 패킷을 보낸다. 클라이언트는 서버에게 연결을 허가하는 패킷을 받았다는 ACK 패킷을 보낸다.

- 왜 3-way handshake를 사용하나요?

TCP는 양방향 통신을 지원하므로, 서버와 클라이언트는 서로 메시지를 주고받을 수 있어야한다. 따라서 서로의 메시지를 잘 주고 받는지 확인하기 위해 최소 3개의 메시지가 필요하다. (서버가 최초로 SYN 패킷에 대한 응답으로 ACK 패킷을 보낼 때 SYN 패킷을 피기배킹할 수 있다.)

### 4-way handshake가 무엇인가요

TCP 프로토콜에서 클라이언트와 서버가 연결을 해제하는 과정이다. 최초에 클라이언트가 서버에게 연결 해제를 요청하는 FIN 패킷을 보낸다. 서버는 클라이언트에게 연결 해제를 승인하는 ACK 패킷을 보낸다. 서버가 클라이언트에게 연결을 해제하는 FIN 패킷을 보낼 때까지 클라이언트는 서버로부터 데이터를 받을 수 있다. 클라이언트는 서버에게 연결 해제를 최종적으로 승인하는 ACK 패킷을 보낸다.

- 왜 3-way handshake가 아니라 4-way handshake를 사용하는가

클라이언트가 연결 해제를 요청하는 SYN 패킷을 보내고 서버가 응답하는 ACK와 연결 해제에 긍정하는 FIN을 함께 보낸다면 서버가 앞서 보낸 패킷이 분실될 수 있다. 

- 4-way handshake 단계를 줄일 수 있을까요?

최초로 클라이언트가 서버에게 보낸 FIN 패킷에 대하여 서버가 ACK, FIN 패킷을 보내면 한 단계를 줄일 수 있다. 하지만 이렇게 하면 서버가 앞서 보낸 패킷이 분실될 수 있다. 또한 서버가 보낼 패킷이 남아있을 수 있다.

### 최초로 연결 설정을 위해 SYN 패킷을 보낼 때, 왜 seq number를 난수로 생성할까?

예측 가능한 seq number는 보안 문제도 있을 것이고, 이전 연결과 구분하기도 어려울 것이다. 예를 들어 클라이언트 A가 서버와 연결한 후 패킷 전송이 지연되어 도착 전 서버와 연결 해제되었다고 하자. 이때 클라이언트 B가 A와 동일한 포트로 서버와 연결한 후 지연된 패킷이 서버에게 도착해도 서버는 A와 B를 구분할 수 없어 B가 요구하지 않은 패킷을 A에게 응답할 것이다. 하지만 최초로 seq number를 생성할 때 난수를 사용하면(ISN; initial sequence number) 서버는 A와 B의 ISN을 비교하여 서로 다른 연결이라는 것을 알 수 있을 것이다.

### TCP와 UDP의 차이

TCP는 연결 지향이나 UDP는 그렇지 않다. TCP는 오류 제어, 흐름 제어, 혼잡 제어 기능을 제공하나 UDP는 그렇지 않다. TCP는 헤더 구조가 복잡하고 데이터의 처리가 느리다. UDP는 헤더 구조가 단순하고 데이터의 처리가 빠르다.

- TCP는 언제 사용하는가

  데이터의 신뢰성을 보장해야하는 경우 사용한다.

- UDP는 언제 사용하는가

  패킷 손실에는 둔감하고 데이터 전송 시간이나 실시간성에 예민한 멀티미디어 응용 환경(스트리밍)에 사용된다.

### TCP keepalive는 언제 사용하는가

3-way handshake로 연결된 종단 연결을 계속 유지하고 싶거나 상대가 살아있는지 확인하기 위해 사용한다.

### QUIC

QUIC(Quic UDP Internet Connection)은 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다. HTTP/3은 QUIC 프로토콜을 사용하는 HTTP이다.

- HTTP/3은 왜 TCP가 아니라 UDP를 사용하는가?

TCP는 연결마다 handshake 과정을 거쳐야하기 때문에 느리며, 패킷이 분실되거나 수신 호스트의 처리 속도가 느리면 병목이 발생할 수 있다. UDP는 데이터그램 방식이므로 연결 설정을 하지 않으며 각각의 패킷은 독립적이므로 데이터 오류가 있어도 병목이 발생하지 않는다.

또한 UDP는 헤더가 간결하여 애플리케이션 레벨에서 커스텀하면 TCP처럼 신뢰성 있는 데이터를 보장할 수 있다.

- UDP가 어떻게 신뢰성 있는 데이터를 보장할 수 있을까?

헤더에 시퀀스 번호를 정의하고 서버와 클라이언트가 데이터 전송 오류가 발생하면 어떻게할 것인지 상호 정의하면 된다.

