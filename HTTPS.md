## HTTPS

**HTTPS(HTTP Secure, HTTP Over Secure Socket Layer)**는 HTTP를 암호화한 버전으로 SSL 프로토콜(TLS 프로토콜)을 사용한다. 기본 포트는 443이다. (SSL은 네스케이프에 의해 발명되었고, IETF로 이관되어 TLS로 불리운다. TLS 1.0이 SSL 3.0을 계승한다.)



## 디지털 서명

디지털 서명(digital sign)은 데이터의 신뢰성을 확인하는데 사용한다. 일반적으로 효율성을 위해 데이터에 해싱을 적용한다.

1. 발신자는 메시지를 해싱하여 해시 값을 만들고 자신의 비밀 키로 해시 값을 암호화하여 서명을 만든다.
2. 발신자는 서명과 메시지(평문)을 전송한다.
3. 수신자는 메시지를 해싱하여 해시 값을 만들고 발신자의 공개 키로 서명을 복호화하여 해시 값과 비교한다.
4. 복호화된 문장과 해시 값이 같다면 이 메시지가 변조되지 않았다는 것이 증명된다.

단, 수신자에게 변조된 공개 키가 전달되었다고 하자. 수신자는 앞으로 변조된 공개 키로 암호화하여 보낼 것이고 공격자는 중간에서 데이터를 가로채어 자신의 비밀 키로 암호문을 복호화할 수 있다. 디지털 서명의 목적은 데이터를 보호하는 것이 아니라 데이터가 변조되지 않았음이다. 데이터를 암호화하는 데 사용한 공개 키가 변조되지 않았는지는 알 수 없다.



## SSL 디지털 인증서

대칭 키는 단순하지만 키 분배 과정에서 키가 탈취당할 수 있다는 위험성이 있다. 공개 키는 비밀 키를 보호할 수 있지만 비밀 키로 복호화하는 연산 비용이 크다는 문제가 있다.

대칭 키와 공개 키 방식을 혼합한 통신을 살펴보자. 두 호스트가 암호화/복호화를 하기 위해 대칭 키 방식을 사용하고, 이 대칭 키를 분배하기 위해 공개 키 방식을 사용하는 것이다.

1. 호스트 A가 자신의 대칭 키를 호스트 B의 공개 키로 암호화하여 B에게 전송한다.
2. 호스트 B는 자신의 비밀 키로 암호문을 복호화한다.
3. 최종적으로 호스트 A와 B는 대칭 키를 분배하게 된다. 앞으로 통신 암호화/복호화 과정에 대칭 키를 사용한다.

대칭 키를 공개 키 방식으로 분배하였고 데이터를 주고받을 때는 대칭 키 방식을 사용하여 각각의 방식에서 장점만 차용하였다. 문제는 호스트 B의 공개 키가 변조되었을 경우 대칭 키가 탈취당할 수 있다. 이때 호스트 B는 자신의 신뢰성을 증명하고 안전하게 공개 키를 제공해야한다.

SSL 통신에서 서버는 SSL 인증서를 통해 클라이언트에게 자신이 신뢰할 수 있는 서버인지 증명하고 안전하게 자신의 공개 키를 제공할 수 있다.

>  SSL 인증서는 클라이언트와 서버 간의 통신을 제3자가 보증해주는 전자화된 문서다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다.

SSL 인증서는 엄격하게 공인된 CA(Certificate Authority)가 발급한다. 인증서에는 인증서를 발급한 CA와 CA의 디지털 서명 등 서비스 정보와 서버의 이름, 공개 키 등 서버의 정보가 포함된다. 클라이언트-곧 브라우저는 CA와 CA의 공개 키의 리스트를 내장하여 인증서의 유효성을 검증한다. SSL 인증서 발급 과정을 포함한 SSL 통신은 다음과 같은 과정을 거친다.

1. 서버가 비밀 키와 공개 키를 생성한다. CA에게 공개 키를 보내어 인증서 발급을 요청한다.
2. CA는 서비스 정보와 서버의 공개 키 정보를 담아 인증서를 만든다. 자신의 비밀 키로 암호화하여 서버에게 인증서를 발급한다.
3. 서버는 클라이언트에게서 온 요청이 자신의 공개 키로 암호화된 HTTPS 요청이 아니면 클라이언트에게 인증서를 보낸다.
4. 클라이언트는 내장하고 있는 CA의 공개 키로 인증서를 복호화하여 유효성을 검증하고 서버의 공개 키를 얻는다.



## HTTPS 동작 과정

클라이언트와 서버가 SSL 통신하는 과정은 아래와 같다.

1. 사용자가 검색창에 `https://www.naver.com`이라고 입력한다.
2. 클라이언트와 서버가 TCP 3-way handshaking으로 TCP 연결을 설정한다. (443번 포트)
3. 클라이언트와 서버가 SSL handshake로 대칭 키를 분배한다.
   1. Client Hello: 클라이언트가 생성한 랜덤 데이터, 클라이언트가 지원하는 암호화 방식, 세션 아이디(기존의 세션이 있다면 재활용)을 전송한다.
   2. Server Hello: 서버가 생성한 랜덤 데이터, 서버가 선택한 암호화 방식, 인증서를 전송한다.
   3. 클라이언트는 CA의 공개 키로 인증서를 복호화하여 인증서의 유효성을 검증하고 서버의 공개 키를 얻는다.
   4. 클라이언트는 서버의 랜덤 데이터와 클라이언트의 랜덤 데이터를 조합하여 pre master secret 값을 만들고 서버의 공개 키로 암호화한다.
   5. 클라이언트는 pre master secret 값을 서버에게 전송하고 서버는 자신의 비밀 키로 해당 값을 복호화한다.
   6. 클라이언트와 서버는 pre master secret 값으로 master secret 값을 생성하고 이 값으로 session key를 만든다.
4. 클라이언트와 서버는 SSL 세션을 사용하여 통신한다: session key로 암호화하여 요청하고 응답한다.
5. 클라이언트와 서버가 SSL 세션을 종료한다: session key를 폐기한다.
6. 클라이언트와 서버가 TCP 4-way handshake로 TCP 연결을 해제한다.



## 참고

- [생활코딩 - HTTPS와 SSL](https://opentutorials.org/course/228/4894)
- [gyoogle - 대칭키 & 공개키.md](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/%EB%8C%80%EC%B9%AD%ED%82%A4%20%26%20%EA%B3%B5%EA%B0%9C%ED%82%A4.md)

- https://devlog-wjdrbs96.tistory.com/289
